#!/usr/bin/env python3
"""melee-gci-compiler.py: Compiles custom data into Melee GCI save files using
   MGC script files"""
import sys
import getopt
import hashlib
from pathlib import Path
import mgc.compiler as compiler
import mgc.logger as logger
from mgc.errors import CompileError

USAGE_TEXT = """\
Usage: melee_gci_compiler.py [options] [script_path]

script_path    The path to the MGC script file you want to compile.
-i             Optionally input a Melee GCI to use its existing data as a base.
-o             The GCI file to output. If omitted, no data will be written.
-h, --help     Displays this usage text.
--nopack       Do not pack the GCI, so you can inspect the outputted data.
--silent       Suppress command line output, except for fatal errors.
--debug        Output extra information while compiling and on errors.
--pal          Switch to PAL memory addresses.

You can omit script_path to pack or unpack a GCI without changing its content.
"""


def main(argv):
    try:
        opts, args = getopt.getopt(argv[1:],'i:o:h',['help','nopack','silent','debug','pal'])
    except getopt.GetoptError:
        return 2
    if len(args) > 1:
        return 2
    elif len(args) == 0 and len(opts) == 0:
        return 0
    script_path = args[0] if args else None
    input_gci = None
    output_gci = None
    nopack = False
    silent = False
    debug = False
    usage = False
    error = False
    pal = False
    for opt, arg in opts:
        match opt:
            case '-h'|'--help': usage = True
            case '-i': input_gci = arg
            case '-o': output_gci = arg
            case '--nopack': nopack = True
            case '--silent': silent = True
            case '--debug': debug = True
            case '--pal': pal = True
            case _: error = True
    if usage:
        print(USAGE_TEXT)
        return 0
    if error:
        return 2
    if not script_path:
        logger.warning("No MGC script specified; no custom data will be compiled")
    try:
        gci_data = compiler.init(script_path, input_gci_path=input_gci,
                                 nopack=nopack, silent=silent, debug=debug, pal=pal)
    except CompileError as e:
        if debug:
            raise
        else:
            logger.error(e.message)
            _cleanup(script_path)
            return 10
    logger.info("Compile successful")
    if not output_gci:
        logger.info("No output GCI specified; no files will be written")
    else:
        if nopack:
            msg = "Writing unpacked GCI file; not loadable by Melee"
        else:
            msg = "Writing final GCI file"
        logger.info(msg)
        _write_gci(output_gci, gci_data, debug)
    md5 = hashlib.md5(gci_data).hexdigest()
    logger.info(f"MD5: {md5}")
    logger.info("All tasks finished")
    _cleanup(script_path)
    return 0


def _write_gci(path: str, data: bytes, debug: bool):
    try:
        with open(path, 'wb') as f: f.write(data)
    except Exception as e:
        if debug:
            raise
        else:
            logger.error(f"Couldn't write GCI file: {e}")


def _cleanup(script_path):
    """Deletes temp files generated by the ASM compiler."""
    if not script_path:
        return
    tmp_path = Path(script_path).parent/"tmp"
    (tmp_path/"code.txt").unlink(missing_ok=True)
    (tmp_path/"code.bin").unlink(missing_ok=True)
    (tmp_path/"src1.o").unlink(missing_ok=True)
    (tmp_path/"src2.o").unlink(missing_ok=True)
    # Remove tmp directory only if empty
    try:
        tmp_path.rmdir()
    except Exception:
        pass
    return


if __name__ == "__main__":
    r = main(sys.argv)
    if r == 2:
        print(USAGE_TEXT)
    sys.exit(r)

