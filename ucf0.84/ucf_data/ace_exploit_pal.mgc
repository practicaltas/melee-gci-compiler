ACE EXPLOIT PAL

This file sets up the data and code for Melee's ACE (Arbitrary Code Execution)
save file exploit. It is required in order to run custom code from a save file.
--------------------------------------------------------------------------------

!begin
# Make the first nametag so long that it overflows into the stack's return pointer
!loc 8044e658

20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
20202020 20202020 20202020 20202020
8044e760 80423d14 804dfe50 801a5b90
20202020 8044e738 20202020 20202020
20202020 8044e760 80423d14 804dfe50
801a5b90 20202020 20202020 20202020
20202020 804dfc50 8044e738 00000000

# This forces execution to branch to 8044e738 instead of back to the nametag
# 801a5b90 is return address after ACE, 804dfe50 is return stack context.
#
#   PAL: 8044e738

# --------------
# PAL Loader 1
# --------------
!loc 8044e738
!asm

mr sp, r30
lwz r4,0(r29)
cmpwi r4,0			#is a memcard save in progress?
beq 0x10
stw r28,0(r29)	#if so, run loader2 when it's done and return
mtctr r31
bctr
mtctr r28			#if not, run loader2 now and set LR to return
mtlr r31
bctr

!asmend

# Now, we branch to the Loader 2 function and run whatever code we want before
# rebooting the game. In this example, we iterate through a datacopy table
# that conveniently lets us copy our custom data to other places in Melee
# memory, away from the save data region. (See datacopy_table_pal.mgc)
# Then, we run the Gecko codehandler one time to apply our Gecko codes.
# Unlike Gecko OS and Nintendont, we don't hook the codehandler to run every
# frame, so keep that in mind if your codes require that.

# --------------
# PAL Loader 2
# --------------

!asm

mflr r0
stw r0,0x4(sp)
stwu sp,-92(sp)
stmw r21, 8(sp)

#r7: pointer to datacopy table
lis r7,0x8045
ori r7,r7,0x186c

#r8: PalDecoding:
lis r8, 0x8044
ori r8, r8, 0xE950
lwz r8, 0(r8)

DATACOPYLOOP:
lwz r4,0(r7)	#source
cmpwi r4,0
beq CODEHANDLER
lwz r3,4(r7)	#destination
lwz r5,8(r7)	#size

#copy data
subi r4,r4,4
subi r6,r3,4
addi r5,r5,4
b 0x10
lwzu r0,0x4(r4)
add r0, r0, r8  #decode
stwu r0,0x4(r6)
subic. r5,r5,4
bne+ -0x10

#next string
addi r7,r7,0xc
b DATACOPYLOOP

CODEHANDLER:

#Run codehandler once
lis r12,0x8045
ori r12,r12,0x1a6c
li r4,0
icbi r4,r12
sync
isync
mtctr r12
bctrl

#Clear cache
lis r3,0x8000
lis r4,0x3c
lis r12,0x8032
ori r12,r12,0x922c
mtctr r12
bctrl

li r3,2
lis r12,0x801A
ori r12,r12,0x4E08
mtctr r12
bctrl

lis r12,0x801a
ori r12,r12,0x5664
mtctr r12
bctrl

#Zero fill entire nametag area, continue execution in stack after
lis r3,0x8044
ori r3,r3,0xe658
li r4,0
li r5,0
ori r5,r5,0xc344
lis r12,0x8000
ori r12,r12,0x3130
mtctr r12
bl 0x4
mflr r12
lmw r21, 0x18(r12)  # load the rest of this function to regs
stmw r21, 52(sp)  # store them on stack
addi r31, sp, 52
mtlr r31
bctr

#Init nametag data. Starting from this point execution done from stack,
#as the memory card nametag area has been wiped clean.
li r3,2
lis r12,0x8015
ori r12,r12,0xff00
mtctr r12
bctrl



#Reload game data and return after

lmw r21, 8(sp)
lis r12,0x8001
ori r12,r12,0xcecc
mtctr r12
addi sp,sp,76
bctr

!asmend